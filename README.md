# ACSE-4-armageddon-Bennu

The first part is about how to install and run the tool. The second part is about the usage instructions.

# 1 Installation

## 1.1 Installing the pre-requisites

To install the module and any pre-requisites:

```
pip install -r requirements.txt
```

## 1.2 Downloading postcode data

To download the postcode data:
```
python download_data.py
```

## 1.3 Automated testing

To run the pytest test suite:
```
python -m pytest armageddon
```

Note that you should keep the tests provided, adding new ones as you develop your code. If any of these tests fail it is likely that the scoring algorithm will not work.

## 1.4 Example usage

For example usage see `example.py`:

```
python example.py
```



## 1.5 Documentation

To generate the documentation (in html format):
```
python -m sphinx docs html
```

See the `docs` directory for the preliminary documentation provided that you should add to.

## 1.6 Example usage

For example usage see `example.py`:
```
python example.py
```



# 2 Usage Instructions

There is four core files in our project and they are:

- solver.py
- damage.py
- locator.py
- mapping.py

Next, we will give a brief description for each file.

## 2.1 solver.py


There are three main functions within this file:
solve_atmospheric_entry, calculate_energy, and analyse_outcome:

    In the solve_atmospheric_entry, we take a series of initial parameters including radius, angle, strength, 
    density and velocity. With the help of RK4 method, we solve five ODE equations to generate a dataframe. In 
    the dataframe, there are relative data of the state of the aerolite in each time slot, which could be 
    processed in the following part.
    
    In the calculate_energy, we add a new column called dedz into the dataframe which is generated by function 
    solve_atmospheric_entry. The dedz represents the variation state of the meteorite's kinetic energy with the change 
    of the altitude. This column is very meaningful as it could help us to judge whether the meteorite is "Airburst" or 
    "Cratering".
    
    In the analyse_outcome part, we use the final processed dataframe to make data analysis. Returing the results of burst
    state, burst_peak_dedz, burst_altitude, burst_distance and burst energy. In the process, we see the altitude where the 
    value of dedz is the biggest as the burst altitude. If the burst altitude is higher than zero, than the state is "Airburst",
    if the burst altitude is equal or lower than zero, we say it's state as "Cratering". The difference between "Airburst" and 
    "Cratering" is that, in the "Cratering" situation, we will take the moment when the meteorite's altitude is most close to 
    the ground as the reference point rather than the moment when the peak of dedz happen.


## 2.2 damage.py

In this file, we take the following external inputs:

* Entry latitude (degrees as a decimal)
* Entry longitude (degrees as a decimal)
* Entry bearing (degrees from north, as a decimal)
* Entry altitude (m)

Plus the outputs from the airburst solver(from the **solver.py** file):

* Burst energy (kt TNT)
* Burst altitude (m)
* Horizontal path length (m)

We use **damage_zone** function to compute the coordinates of the surface zero location(latitude and longitude included) and the airblast damage radii(with different degrees of damage) .

## 2.3 locator.py

In this file we have two functions and a class:

function:
1. def great_circle_distance - Takes external inputs of list of lists of pairs of latitude and longitudes
    from damage.py
2. def great_circle_distance_dataframe - Takes internal inputs to create a dataframe of distances
    from PostcodeLocator

class:
1. PostcodeLocator - 

    - get_postcodes_by_radius (External inputs of radius,
        latitude and longitude pair, sector specification)
    - get_population_of_postcode (internal input of list of
        postcodes for radius postcodes, sector specification)

where to get inputs, use which function and what the outputs are

## 2.4 mapping.py

where to get inputs, use which function and what the outputs are

This file plots damage area over a map using the function plot_circle, with functionality, inputs, and outputs as follows:

Plot a circle on a map (creating a new folium map instance if necessary).

    Parameters
    ----------
    
    lat: float
        latitude of circle to plot (degrees)
    lon: float
        longitude of circle to plot (degrees)
    radius: float or a list
        radius of circle(s) to plot (m) 
    map: folium.Map 
        existing map object
    show_hospital: flag
        show hospitals information in the map or not
    show_school": flag
        show primaryschools information in the map or not
    dynamic_graph: flag
        show the dynamic heatmap or still heatmap
    
    Returns
    -------
    
    Folium map object

# 3 Extended Functionality

## 3.1 Uncertainty Analysis

In this part, we performed a simple uncertainty analysis where the uncertainty of each input parameter (derived from **solver.py**) can be assumed to follow a Gaussian distribution. Calculate n times using the **impact_risk** function to get the probability of each postcode/sector being affected, which is multiplied by the total population to get the risk of each postcode/sector.

# 4 More information

For more information on the project specification, see the python notebooks: `ProjectDescription.ipynb`, `AirburstSolver.ipynb` and `DamageMapper.ipynb`.
